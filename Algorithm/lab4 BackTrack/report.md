## lab4 最佳调度问题的回溯算法

### 实验要求

> 设有 *n*个任务由 *k*个可并行工作的机器来完成，完成任务*i*需要时间为ti。试设计一个算法找出完成这*n*个任务的最佳调度，使完成全部任务的时间最早。（要求给出调度方案）
>
> 附加说明：完成全部任务的时间为运行时间最长的机器上运行的总时间，所有机器都是相同的。一个任务只能在一个机器上完成，且在完成之前不会被其他任务抢占。



### 算法

****

**算法核心思想**

排列树回溯法+剪枝

**解空间的表示**

一个深度为n的k叉排列树

**基本思路**

1. 搜索从根节点出发，以DFS搜索整个解空间。每搜索完一条路径则记录下bestTime和best_N_to _K[ ]序列 (用于构造最优解)
2. 开始结点就成为一个活结点，同时也成为当前的扩展结点。在当前的扩展结点处向纵深方向移至一个新结点，并成为一个新的活结点，也成为当前扩展结点。如果在当前扩展结点处不能再向纵深方向扩展，则当前扩展结点就成为死结点。
3. 此时，应回溯到最近的一个活结点处，并使这个活结点成为当前的扩展结点。直至找到一个解或全部解。

**算法效率改进**

1. 设定减枝策略
2. 思考启发式搜索方法，尽快找到最优解
3. 备份每个搜索过的结点



## 测试

**三个测试样例**

```c
1、n=10, k=3, 
任务的时间分别为 47, 20, 28, 44, 21, 45, 30, 39, 28, 33
    
2、n=15, k=5, 
任务的时间分别为 98, 84, 50, 23, 32, 99, 22, 76, 72, 61, 81, 39, 76, 54, 37
    
3、n=19, k=8, 
任务的时间分别为 39, 39, 23, 45, 100, 69, 21, 81, 39, 55, 20, 86, 34, 53, 58, 99, 36, 45, 46
```


