## 算法说明

推荐系统中最为主流与经典的技术之一是协同过滤技术，它是基于这样的假设：用户如果在过去对某些项目产生过兴趣，那么将来他很可能依然对其保持热忱。其中协同过滤技术又可根据是否采用了机器学习思想建模的不同划分为基于内存的协同过滤（Memory-based CF）与基于模型的协同过滤技术（Model-based MF)。

本课程设计实现如下4个算法，并进行对比评测。

<img src="E:\同步文件夹\大三下\人工智能\lab\lab3 课程设计\pic\1.png" style="zoom:50%">

### 一.基于用户协同过滤

****

**1.算法介绍**

User-based协同过滤推荐根据其他用户的观点产生对目标用户的推荐列表。它基于这样一个假设: 如果用户对一些项的评分比较相似, 则他们对其他项的评分也比较相似。

协同过滤推荐系统使用统计技术搜索目标用户的若干最近邻居，根据最近邻居对项的评分预测目标用户对未评分项的评分。

算法步骤: (1)得到User-Item评分数据矩阵 (2)针对项的最近邻搜索，对项进行相似度计算。常用算法包括皮尔森相关系数,余弦相似性, 条件概率等 (3)产生预测

<img src="G:\github\Junior\AI\lab3\pic\1.png" style="zoom:60%">

**2.实现说明**

- 调用numpy处理矩阵运算, 算法逻辑自行实现

- 数据预处理得到(user_id, movie_id, rating)三元组, 构建2个评分矩阵(训练和测试), 行号为user_id, 列号为movie_id, 矩阵内容为评分数值 

- 计算用户余弦相似度(根据用户的评分向量计算，也可以在向量中添加性别、职业等属性)

  <img src="G:\github\Junior\AI\lab3\pic\2.png" style="zoom:60%">

- 计算评分: sim表示用户u和用户n之间的相似性, R<sub>n,i</sub>表示用户n对项目i的评分，R<sub>u</sub>-和R<sub>n</sub>-分别表示用户u和用户n对所有项目的平均评分。 

  <img src="G:\github\Junior\AI\lab3\pic\5.png" style="zoom:60%">

**3.总结**

- 适用于用户较少的场合，如果用户很多，计算用户相似度矩阵代价很大
- 时效性较强，适用于用户个性化兴趣不太明显的领域
- 用户有新行为，不一定造成推荐结果的立即变化
- 冷启动问题: 在新用户对很少的物品产生行为后，不能立即对他进行个性化推荐，因为用户相似度表需要每隔一段时间离线计算。新物品上线后一段时间，一旦有用户对物品产生行为，就可以将新物品推荐给和对它产生行为的用户兴趣相似的其他用户
- 很难提供令用户信服的推荐解释

**4.评测结果**

| train:test | RMSE |
| ---------- | ---- |
| 6:4        | 3.35 |
| 7:3        | 3.29 |
| 8:2        | 3.23 |



### 二.基于项目协同过滤

------

**1.算法介绍**

User-based协同过滤推荐根据其他用户的观点产生对目标用户的推荐列表。它基于这样一个假设: 如果大部分用户对一些项的评分比较相似, 则他们对其他相似项的评分也比较相似。

协同过滤推荐系统使用统计技术搜索目标项的若干最近邻居，根据当前用户对最近邻居的评分预测目标用户对未评分目标项的评分。

<img src="G:\github\Junior\AI\lab3\pic\3.png" style="zoom:60%">

**2.实现说明**

- 调用numpy处理矩阵运算, 算法逻辑自行实现

- 数据预处理得到(user_id, movie_id, rating)三元组, 构建2个评分矩阵(训练和测试), 行号为user_id, 列号为movie_id, 矩阵内容为评分数值 

- 计算电影余弦相似度(根据一部电影的评分向量计算，也可以在向量中添加电影类别等属性)

  <img src="G:\github\Junior\AI\lab3\pic\2.png" style="zoom:60%">

- 计算评分: sim表示电影i和电影j之间的相似性, R<sub>u,j</sub>表示用户u对电影j的评分，P<sub>ui</sub>表示用户u对电影i的评分预测值
  $$
  P_{ui}=\frac{\sum R_{uj}*sim(i,j)}{\sum sim(i,j)}
  $$



**3.总结**

- 适用于物品数明显小于用户数的场合，如果物品很多（网页），计算物品相似度矩阵代价很大
- 适用于用户个性化需求强烈的领域
- 用户有新行为，一定会导致推荐结果的实时变化
- 利用用户的历史行为给用户做推荐解释，可以令用户比较信服

**4.评测结果**

| train:test | RMSE |
| ---------- | ---- |
| 6:4        | 3.58 |
| 7:3        | 3.55 |
| 8:2        | 3.53 |



### 三.卷积神经网络

****

**1.算法介绍**

- 卷积神经网络依旧是层级网络，只是层的功能和形式做了变化，可以说是传统神经网络的一个改进

- 积神经网络的层级结构

  -数据输入层/ Input layer ，
  -卷积计算层/ CONV layer , 
  -ReLU激励层 / ReLU layer
  -池化层 / Pooling layer，
  -全连接层 / FC layer，两层之间所有神经元都有权重连接，通常全连接层在卷积神经网络尾部。也就是跟传统的神经网络神经元的连接方式是一样的

**2.实现说明**

- 重复实现一个开源项目, 进行优化和修改, 尝试使用 tensorflow 自己的 batch 方法, 修改用户特征维度, 将顺序获取样本改为随机获取样本等.
- 用户特征提取: 由`user_id`,`gender`,`age`,`occupation`提取得到(N,200)的矩阵，表示用户特征
  - `age`: 7个年龄段 {<18, 18-24, 25-34, 35-44, 45-49, 50-55, 56+ }, 分别用数字0~6表示
  - `gender`: F/M用0/1表示
- 电影特征提取:由`item_id`,`genre`提取得到(N,200)的矩阵，表示电影特征
  - `genres`: 每个电影种类用一个数字表示，比如喜剧用2表示。因为共有18个种类，故对于一部具体的电影，用一个18维的向量来表示它的种类。如果一部电影是戏剧，则用18维向量（2, Y, Y, ..., Y）来表示它的种类。Y是用来填充维度的数字
- 损失函数使用RMSE，优化方法调用tensorflow的`optimizer = tf.train.AdamOptimizer()` ,batch_size=256
- 预测评分: 得到用户特征和电影特征后，使用拟合评分,将用户特征和电影特征做矩阵乘法得到一个预测评分

**3.总结**

- 部分字段是类型性变量，特征工程上可以采用 `one-hot` 编码，但是对于 UserID、MovieID 这样非常稀疏的变量，如果使用 `one-hot`，那么数据的维度会急剧膨胀，对于这份数据集来说是不合适的
- 卷积网络在本质上是一种输入到输出的映射，它能够学习大量的输入与输出之间的映射关系，而不需要任何输入和输出之间的精确的数学表达式，只要用已知的模式对卷积网络加以训练，网络就具有输入输出对之间的映射能力
- CNN不足在于算法缺乏一定的可解释性，要耗费大量的计算资源

**4.评测结果**

RMSE=sqrt(MSE)=0.87

<img src="G:\github\Junior\AI\lab3\pic\9.png" style="zoom:60%">

![1559658822522](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1559658822522.png)

![1559658716385](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1559658716385.png)





### 四.矩阵分解

****

基于模型的协同过滤技术中尤为矩阵分解(MF)技术最为普遍和流行，因为它的可扩展性极好并且易于实现。原理是通过一定数量的因子来描述各个用户的喜好和各个物品的属性。

**1.算法介绍**

- 构建用户-物品的评分矩阵R<sub>m,n</sub>

- 对R作矩阵分解R<sub>m,n</sub> = P<sub>m,k</sub> X  Q<sub>k,n</sub> ,k为待调节的参数, 通常为10-100

- 定义损失函数，评价分解的好坏

- 确定优化算法, 比如梯度下降。迭代计算得到P,Q矩阵

- 得到预测值 P
  $$
  P_{ui}=\sum_{k} P_{uk}*P_{ki}
  $$



**2.实现说明**

- 数据预处理得到(user_id, movie_id, rating)三元组, 构建2个评分矩阵(训练和测试), 行号为user_id, 列号为movie_id, 矩阵内容为评分数值。并进行规范化, 算出均值, 评分在原评分基础上减去均值 
- 设定维度k=10，随机初始化矩阵P 和 Q
- 调用tensorflow的`optimizer = tf.train.AdamOptimizer()` 优化方法，迭代3000次得到收敛结果
- 得到预测值并进行评估

**3.总结**

- 矩阵分解可扩展性好, 可与其他算法做结合
- 矩阵分解是协同过滤模型中经典的方法，性能十分优良。但存在数据稀疏与冷启动问题。结合外部丰富的信息可以缓解上述问题

**4.评测结果**

<img src="G:\github\Junior\AI\lab3\pic\7.png" style="zoom:60%">



### 五.扩展

****

- [16年一篇文章](https://wenku.baidu.com/view/d332187db4daa58da0114a66.html)将矩阵分解(MF)与卷积神经网络(CNN)做了结合





| 算法       | RMSE |
| ---------- | ---- |
| user-based | 3.35 |
| item-based | 3.53 |
| CNN        | 0.87 |
| MF         | 0.80 |



****

【ref】

- [基于用户/项目的协同过滤](https://wenku.baidu.com/view/d332187db4daa58da0114a66.html)
- [卷积神经网络](https://www.cnblogs.com/skyfsm/p/6790245.html)
- [基于矩阵分解的推荐系统](https://www.cnblogs.com/kobedeshow/p/3651833.html)

