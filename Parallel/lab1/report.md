## lab 1 计算Π值&PSRS算法

### 一.计算Π值

Π值的计算公式如下:
$$
{4\int_{0}^1 \frac{1}{1+x^2}dx= 4arctan(1)}={\pi}
$$
将区间[0,1]等分为n份, 每份长度为h，设
$$
f(x)=\frac {1}{1+x^2} , h={1 \over n}
$$
利用数值积分可以得到:
$$
\pi=4\int_{0}^1 f(x)dx=\sum_{i=0}^n4hf(hi)
$$

**1.使用并行域并行化的程序**

- 两个线程0和1参加计算，线程0迭代步0,2,4,...线程1迭代步1,3,5,..
- 设置一段并行域，每个线程都会执行该代码
- 每个线程有一个私有变量i，通过线程id的不同来找到计算结果的存储位置
- 每个线程有各自的sum值，最后两个sum值相加得到总sum值

**2.使用共享任务结构并行化的程序**

- 两个线程0和1参加计算，线程0迭代步0~499999, 线程1迭代步500000~999999

- 设置一段并行域，每个线程都会执行该代码
- 计算任务迭代平均分配给各线程，连续划分
- 每个线程有各自的sum值，最后两个sum值相加得到总sum值

**3.使用private子句和critical部分并行化的程序**

- 两个线程0和1参加计算，线程0迭代步0,2,4,...线程1迭代步1,3,5,..
- 同一时间临界区中代码最多只能由一个线程执行，其他线程若也到达临界区，则会被阻塞，直到当前线程执行完毕
- 与方法一相比，只是把总sum值的计算放入了并行域

**4.使用并行规约的并行程序**

- 两个线程0和1参加计算，线程0迭代步0~499999, 线程1迭代步500000~999999

- 每个线程保留一份私有拷贝sum, x为线程私有。最后对线程中所有sum进行+规约，并更新sum的全局值





### 二. PSRS算法的设计

**1.PSRS算法步骤**

- 均匀划分: 将n个元素均匀划分为p段, 每段标号为i
- 局部排序: 段内串行排序
- 正则采样: 每个段选p个样本元素
- 采样排序: 对选出的p*p个元素串行排序
- 选择主元: 从p*p个元素中选择(p-1)个元素，播送给所有段
- 主元划分: 段内根据 主元，划分为p段，标号为j
- 全局交换: 根据主元划分结果,全局重新划分为p段
- 归并排序: 段内归并排序

**2.伪代码**

```c
//第一个并行域：
#pragma omp parallel shared(base,array,n,i,pivot,count) private(id)
{
　　每个处理器对所在的段进行局部串行归并排序；
　　
　　#pragma omp critical
　　{
　　　　每个处理器选出p个样本；
    }
　　设置路障#pragma omp barrier
      
　　主线程并行域#pragma omp master
　　{
   　　 选出num_threads-1个主元
　　}
　　设置路障#pragma omp barrier
      
　　{
    　　根据主元对每一个cpu数据进行划分
　　}
}

//第二个并行域：
＃pragma omp parallel shared(pivot_array,count)
{
　　向各个线程发送数据，各个线程自己排序；
}
```





****

【Ref】

- Devcpp中使用openmp

  工具--编译选项--勾选 “编译时加入如下命令--” 输入“-fopenmp”

